{"ast":null,"code":"import _slicedToArray from \"/Users/alberttian/f21/playground/frontend/fencing-ai-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/alberttian/f21/playground/frontend/fencing-ai-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { getParamValue } from './utils';\nexport var executeOp = function executeOp(node, tensorMap, context) {\n  switch (node.op) {\n    case 'BatchMatMul':\n    case 'BatchMatMulV2':\n    case 'MatMul':\n      return [tfOps.matMul(getParamValue('a', node, tensorMap, context), getParamValue('b', node, tensorMap, context), getParamValue('transposeA', node, tensorMap, context), getParamValue('transposeB', node, tensorMap, context))];\n\n    case 'Einsum':\n      return [tfOps.einsum.apply(tfOps, [getParamValue('equation', node, tensorMap, context)].concat(_toConsumableArray(getParamValue('tensors', node, tensorMap, context))))];\n\n    case 'Transpose':\n      return [tfOps.transpose(getParamValue('x', node, tensorMap, context), getParamValue('perm', node, tensorMap, context))];\n\n    case '_FusedMatMul':\n      var _getParamValue = getParamValue('fusedOps', node, tensorMap, context),\n          _getParamValue2 = _slicedToArray(_getParamValue, 2),\n          extraOp = _getParamValue2[0],\n          activationFunc = _getParamValue2[1];\n\n      var isBiasAdd = extraOp === 'biasadd';\n      var isPrelu = activationFunc === 'prelu';\n      var numArgs = getParamValue('numArgs', node, tensorMap, context);\n      var leakyreluAlpha = getParamValue('leakyreluAlpha', node, tensorMap, context);\n\n      if (isBiasAdd) {\n        if (isPrelu && numArgs !== 2) {\n          throw new Error('Fused MatMul with BiasAdd and Prelu must have two ' + 'extra arguments: bias and alpha.');\n        }\n\n        if (!isPrelu && numArgs !== 1) {\n          throw new Error('Fused MatMul with BiasAdd must have one extra argument: bias.');\n        }\n      }\n\n      var _getParamValue3 = getParamValue('args', node, tensorMap, context),\n          _getParamValue4 = _slicedToArray(_getParamValue3, 2),\n          biasArg = _getParamValue4[0],\n          preluArg = _getParamValue4[1];\n\n      return [tfOps.fused.matMul({\n        a: getParamValue('a', node, tensorMap, context),\n        b: getParamValue('b', node, tensorMap, context),\n        transposeA: getParamValue('transposeA', node, tensorMap, context),\n        transposeB: getParamValue('transposeB', node, tensorMap, context),\n        bias: biasArg,\n        activation: activationFunc,\n        preluActivationWeights: preluArg,\n        leakyreluAlpha: leakyreluAlpha\n      })];\n\n    default:\n      throw TypeError(\"Node type \".concat(node.op, \" is not implemented\"));\n  }\n};\nexport var CATEGORY = 'matrices';","map":{"version":3,"sources":["../../../src/operations/executors/matrices_executor.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor, Tensor2D} from '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\n\nimport {NamedTensorsMap} from '../../data/types';\nimport {ExecutionContext} from '../../executor/execution_context';\nimport {InternalOpExecutor, Node} from '../types';\n\nimport {getParamValue} from './utils';\n\nexport const executeOp: InternalOpExecutor =\n    (node: Node, tensorMap: NamedTensorsMap,\n     context: ExecutionContext): Tensor[] => {\n      switch (node.op) {\n        case 'BatchMatMul':\n        case 'BatchMatMulV2':\n        case 'MatMul':\n          return [tfOps.matMul(\n              getParamValue('a', node, tensorMap, context) as Tensor2D,\n              getParamValue('b', node, tensorMap, context) as Tensor2D,\n              getParamValue('transposeA', node, tensorMap, context) as boolean,\n              getParamValue('transposeB', node, tensorMap, context) as\n                  boolean)];\n\n        case 'Einsum':\n          return [tfOps.einsum(\n              getParamValue('equation', node, tensorMap, context) as string,\n              ...getParamValue('tensors', node, tensorMap, context) as\n                  Tensor[])];\n\n        case 'Transpose':\n          return [tfOps.transpose(\n              getParamValue('x', node, tensorMap, context) as Tensor,\n              getParamValue('perm', node, tensorMap, context) as number[])];\n\n        case '_FusedMatMul':\n          const [extraOp, activationFunc] =\n              (getParamValue('fusedOps', node, tensorMap, context) as string[]);\n\n          const isBiasAdd = extraOp === 'biasadd';\n          const isPrelu = activationFunc === 'prelu';\n\n          const numArgs =\n              (getParamValue('numArgs', node, tensorMap, context) as number);\n          const leakyreluAlpha =\n              getParamValue('leakyreluAlpha', node, tensorMap, context) as\n              number;\n\n          if (isBiasAdd) {\n            if (isPrelu && numArgs !== 2) {\n              throw new Error(\n                  'Fused MatMul with BiasAdd and Prelu must have two ' +\n                  'extra arguments: bias and alpha.');\n            }\n            if (!isPrelu && numArgs !== 1) {\n              throw new Error(\n                  'Fused MatMul with BiasAdd must have one extra argument: bias.');\n            }\n          }\n          const [biasArg, preluArg] =\n              getParamValue('args', node, tensorMap, context) as Tensor[];\n          return [tfOps.fused.matMul({\n            a: getParamValue('a', node, tensorMap, context) as Tensor2D,\n            b: getParamValue('b', node, tensorMap, context) as Tensor2D,\n            transposeA: getParamValue('transposeA', node, tensorMap, context) as\n                boolean,\n            transposeB: getParamValue('transposeB', node, tensorMap, context) as\n                boolean,\n            bias: biasArg,\n            activation: activationFunc as tfOps.fused.Activation,\n            preluActivationWeights: preluArg,\n            leakyreluAlpha\n          })];\n\n        default:\n          throw TypeError(`Node type ${node.op} is not implemented`);\n      }\n    };\n\nexport const CATEGORY = 'matrices';\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}