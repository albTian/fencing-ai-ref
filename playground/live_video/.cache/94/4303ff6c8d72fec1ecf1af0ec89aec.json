{"id":"DGmS","dependencies":[{"name":"/Users/alberttian/f21/playground/frontend/live_video/node_modules/@tensorflow/tfjs-backend-webgl/dist/top_k_gpu.js.map","includedInParent":true,"mtime":1631991247369},{"name":"/Users/alberttian/f21/playground/frontend/live_video/package.json","includedInParent":true,"mtime":1633056435183},{"name":"/Users/alberttian/f21/playground/frontend/live_video/.babelrc","includedInParent":true,"mtime":1633056216691},{"name":"/Users/alberttian/f21/playground/frontend/live_video/node_modules/@tensorflow/tfjs-backend-webgl/package.json","includedInParent":true,"mtime":1631991247369}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.MergeProgram=exports.SwapProgram=void 0;class e{constructor(e){this.variableNames=[\"x\",\"indices\"],this.customUniforms=[{name:\"n\",type:\"int\"},{name:\"firstPass\",type:\"int\"},{name:\"negativeInf\",type:\"float\"},{name:\"dir\",type:\"int\"},{name:\"inc\",type:\"int\"}],this.outputShape=e,this.userCode=\"\\n       void main() {\\n         ivec2 coords = getOutputCoords();\\n         int batch = coords[0];\\n         int elemIdx = coords[1];\\n\\n         // We compare elements pair-wise within a group of size 2 * inc.\\n         // The comparing rule for each group alternates between ascending\\n         // and descending. Within each group, we compare each pair at\\n         // positions i and i+inc. To decide whether an element at position i\\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\\n         // inc, it is in the first half of the group, we denote it as x0,\\n         // otherwise we denote it as x1.\\n         // For example, as shown in the Bitonic top K paper referenced above,\\n         // Figure5(a) shows that element[1] is in the\\n         // second half of the group when group size is 2, but it is in the\\n         // first half of the group when group size is 4.\\n\\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\\n\\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\\n\\n         // Denotes which direction indices are in (ascending or descending).\\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\\n         if (reverse == isGreater) { // Elements in opposite order of direction\\n           int iTemp = i0;\\n           i0 = i1;\\n           i1 = iTemp;\\n         }\\n         if (isFirstInPair) {\\n            setOutput(float(i0));\\n         } else {\\n            setOutput(float(i1));\\n         }\\n       }\\n     \"}}exports.SwapProgram=e;class n{constructor(e){this.variableNames=[\"x\",\"indices\"],this.customUniforms=[{name:\"n\",type:\"int\"},{name:\"firstPass\",type:\"int\"},{name:\"k\",type:\"int\"}],this.outputShape=e,this.userCode=\"\\n    void main() {\\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\\n         ivec2 coords = getOutputCoords();\\n         int batch = coords[0];\\n         int elemIdx = coords[1];\\n\\n         // The output size is half of the previous size.\\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\\n         // we only need to output the indices at positions |, the indices at\\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\\n         // (Merge phase) in the Bitonic Top K paper referenced above.\\n         // For example, the paper shows we only need to output the orange bars.\\n         // The output sequence should look like this | | | | | | | |.\\n         // Because the sequence is halved, to map the output index back\\n         // to the previous sequence to find the corresponding value,\\n         // we need to double the index. When we double the index,\\n         // we basically interpolate a position, so 2i looks like\\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\\n         // of each 2k positions by - elemIdx % k. E.g. for output at\\n         // index 4,5,6,7, we want to get the corresponding element at\\n         // original index 8,9,10,11, for output at index 8,9,10,11,\\n         // we want to get the corresponding element at original index\\n         // 16,17,18,19, so on and so forth.\\n\\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\\n\\n         float x0 = getX(batch, i0);\\n         float x1 = i1 < n ? getX(batch, i1) : x0;\\n\\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\\n       }\\n     \"}}exports.MergeProgram=n;"},"sourceMaps":{"js":{"mappings":[{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":96,"column":25},"generated":{"line":1,"column":0}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":96,"column":25},"generated":{"line":1,"column":13}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":96,"column":25},"generated":{"line":1,"column":20}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":96,"column":25},"generated":{"line":1,"column":35}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":96,"column":25},"generated":{"line":1,"column":43}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":96,"column":25},"generated":{"line":1,"column":56}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":96,"column":25},"generated":{"line":1,"column":57}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":96,"column":25},"generated":{"line":1,"column":64}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":96,"column":25},"generated":{"line":1,"column":68}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":96,"column":25},"generated":{"line":1,"column":76}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":96,"column":25},"generated":{"line":1,"column":89}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":96,"column":25},"generated":{"line":1,"column":97}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":96,"column":25},"generated":{"line":1,"column":114}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":29,"column":6},"generated":{"line":1,"column":116}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":29,"column":13},"generated":{"line":1,"column":122}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":49,"column":2},"generated":{"line":1,"column":124}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":49,"column":14},"generated":{"line":1,"column":136}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":30,"column":2},"generated":{"line":1,"column":139}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":30,"column":2},"generated":{"line":1,"column":144}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":30,"column":18},"generated":{"line":1,"column":158}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":30,"column":19},"generated":{"line":1,"column":159}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":30,"column":24},"generated":{"line":1,"column":163}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":37,"column":2},"generated":{"line":1,"column":174}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":37,"column":2},"generated":{"line":1,"column":179}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":37,"column":19},"generated":{"line":1,"column":194}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":38,"column":4},"generated":{"line":1,"column":195}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":38,"column":5},"generated":{"line":1,"column":196}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":38,"column":11},"generated":{"line":1,"column":201}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":38,"column":16},"generated":{"line":1,"column":205}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":38,"column":22},"generated":{"line":1,"column":210}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":39,"column":4},"generated":{"line":1,"column":217}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":39,"column":5},"generated":{"line":1,"column":218}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":39,"column":11},"generated":{"line":1,"column":223}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":39,"column":24},"generated":{"line":1,"column":235}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":39,"column":30},"generated":{"line":1,"column":240}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":40,"column":4},"generated":{"line":1,"column":247}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":40,"column":5},"generated":{"line":1,"column":248}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":40,"column":11},"generated":{"line":1,"column":253}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":40,"column":26},"generated":{"line":1,"column":267}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":40,"column":32},"generated":{"line":1,"column":272}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":41,"column":4},"generated":{"line":1,"column":281}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":41,"column":5},"generated":{"line":1,"column":282}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":41,"column":11},"generated":{"line":1,"column":287}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":41,"column":18},"generated":{"line":1,"column":293}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":41,"column":24},"generated":{"line":1,"column":298}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":42,"column":4},"generated":{"line":1,"column":305}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":42,"column":5},"generated":{"line":1,"column":306}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":42,"column":11},"generated":{"line":1,"column":311}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":42,"column":18},"generated":{"line":1,"column":317}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":42,"column":24},"generated":{"line":1,"column":322}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":50,"column":9},"generated":{"line":1,"column":330}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":50,"column":9},"generated":{"line":1,"column":335}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":50,"column":23},"generated":{"line":1,"column":347}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":52,"column":9},"generated":{"line":1,"column":349}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":52,"column":9},"generated":{"line":1,"column":354}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":52,"column":20},"generated":{"line":1,"column":363}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":96,"column":25},"generated":{"line":1,"column":2179}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":96,"column":25},"generated":{"line":1,"column":2187}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":96,"column":25},"generated":{"line":1,"column":2199}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":96,"column":6},"generated":{"line":1,"column":2201}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":96,"column":13},"generated":{"line":1,"column":2207}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":113,"column":2},"generated":{"line":1,"column":2209}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":113,"column":14},"generated":{"line":1,"column":2221}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":97,"column":2},"generated":{"line":1,"column":2224}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":97,"column":2},"generated":{"line":1,"column":2229}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":97,"column":18},"generated":{"line":1,"column":2243}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":97,"column":19},"generated":{"line":1,"column":2244}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":97,"column":24},"generated":{"line":1,"column":2248}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":104,"column":2},"generated":{"line":1,"column":2259}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":104,"column":2},"generated":{"line":1,"column":2264}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":104,"column":19},"generated":{"line":1,"column":2279}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":105,"column":4},"generated":{"line":1,"column":2280}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":105,"column":5},"generated":{"line":1,"column":2281}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":105,"column":11},"generated":{"line":1,"column":2286}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":105,"column":16},"generated":{"line":1,"column":2290}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":105,"column":22},"generated":{"line":1,"column":2295}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":106,"column":4},"generated":{"line":1,"column":2302}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":106,"column":5},"generated":{"line":1,"column":2303}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":106,"column":11},"generated":{"line":1,"column":2308}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":106,"column":24},"generated":{"line":1,"column":2320}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":106,"column":30},"generated":{"line":1,"column":2325}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":107,"column":4},"generated":{"line":1,"column":2332}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":107,"column":5},"generated":{"line":1,"column":2333}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":107,"column":11},"generated":{"line":1,"column":2338}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":107,"column":16},"generated":{"line":1,"column":2342}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":107,"column":22},"generated":{"line":1,"column":2347}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":114,"column":9},"generated":{"line":1,"column":2355}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":114,"column":9},"generated":{"line":1,"column":2360}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":114,"column":23},"generated":{"line":1,"column":2372}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":116,"column":9},"generated":{"line":1,"column":2374}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":116,"column":9},"generated":{"line":1,"column":2379}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":116,"column":20},"generated":{"line":1,"column":2388}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":96,"column":25},"generated":{"line":1,"column":4191}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":96,"column":25},"generated":{"line":1,"column":4199}},{"source":"../src/top_k_gpu.ts","name":null,"original":{"line":96,"column":25},"generated":{"line":1,"column":4212}}],"sources":{"../src/top_k_gpu.ts":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {GPGPUProgram} from './gpgpu_math';\nimport {UniformType} from './shader_compiler';\n\n// Based on Algorithm 2 of Bitonic Top K, ref:\n// https://anilshanbhag.in/static/papers/gputopk_sigmod18.pdf\n// The original algorithm is based on computing the top K only, however\n// since for TFJS we require the indices of the top K values as well then the\n// algorithm found here is a bit modified. Rather than producing the values\n// at each step, the indices containing the top K are generated instead.\n// The output values are not generated to reduce the number of outputs in the\n// GPU, the values can easily be retrieved from the indices using a gather\n// op.\nexport class SwapProgram implements GPGPUProgram {\n  variableNames = ['x', 'indices'];\n  outputShape: number[];\n  userCode: string;\n  // |n| Size of the original input of TopK.\n  // |firstPass|indicates if this is the first time swap is being used which\n  // means no indices input containing the top K is present yet.\n  // |inc| Swaps pairs of indices (0, inc), (1, inc + 1), (2, inc + 2) ...\n  customUniforms = [\n    {name: 'n', type: 'int' as UniformType},\n    {name: 'firstPass', type: 'int' as UniformType},\n    {name: 'negativeInf', type: 'float' as UniformType},\n    {name: 'dir', type: 'int' as UniformType},\n    {name: 'inc', type: 'int' as UniformType}\n  ];\n\n  /**\n   * @param shape desired output shape (can be larger than input shape, output\n   *                                    will be padded with -Infinity)\n   */\n  constructor(shape: number[]) {\n    this.outputShape = shape;\n\n    this.userCode = `\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     `;\n  }\n}\n\nexport class MergeProgram implements GPGPUProgram {\n  variableNames = ['x', 'indices'];\n  outputShape: number[];\n  userCode: string;\n  // |n| Size of the original input of TopK\n  // |firstPass| indicates if this is the first time swap is being used which\n  // means no indices input containing the top K is present yet.\n  // |k| Top k elements desired\n  customUniforms = [\n    {name: 'n', type: 'int' as UniformType},\n    {name: 'firstPass', type: 'int' as UniformType},\n    {name: 'k', type: 'int' as UniformType}\n  ];\n\n  /**\n   * @param shape desired output shape (must be half of the input size)\n   */\n  constructor(shape: number[]) {\n    this.outputShape = shape;\n\n    this.userCode = `\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     `;\n  }\n}\n"},"lineCount":null}},"error":null,"hash":"299986c42e27a288cb6f4eca70dc0693","cacheData":{"env":{}}}